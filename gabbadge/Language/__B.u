class Unify : Language {

	//Call to a super constructor is dependant on the method
    constructor(definitions, code) {
        super(definitions, code);
        /*
        since we have function also we will have to
        check in this class if the function tokenizer exists first before
        we run the required tokenizer;
        check class then check package
        */
        tokenize();
    }

    /**
    run the super constructor before running
    this constructor
    */
    constructor -> super.constructor(){

    }


    get separation() {
        return `(${this.omSpace}|${this.omTab})`
    }

    tokenize() {
        let {
                code, definitions: defn,
                structure: {sace, tab, colon, newLine, extnd},
                operators, tokens, token, separation: sep, omSpace, omTab
            } = this,
            {OBJECT_IDENTIFIER} = tokens,
            Class = `(interface|class|trait|abstract${sep}class)${sep}${OBJECT_IDENTIFIER}`,
            oSep = `${sep}?`,
            classExtends = `(${extnd}${oSep}${OBJECT_IDENTIFIER}((${oSep},${oSep}${OBJECT_IDENTIFIER})+)?)`,
            classImplements = `((implements|::))`,
            applyTrait = ``,
            classStartBrace = `\\{`,
            classStart = `${Class}${oSep}${classExtends}?${classImplements}`,
            classRegex = `${classStart}`;

        let regex = new RegExp(classRegex, 'g'),
            matched = regex[Symbol.match](code);

        if (matched) {
            matched.forEach(match => {
                log(match)
            })
        }
    }

    parse() {

    }
}