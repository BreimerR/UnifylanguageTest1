class Object : Array {
	// this
	native find(name) {

	}
	// is a key value pair structure
	__get (name) =>{
		return this.find(name);
	}

	__set(name,value){

	}

	native length(){

	}
}


class Class : Object{
	// a class extends two classes the main class and a simple class

	__call(){

	}
}

class Array{
	// function returns a type Int,Array,etc.
	// T tells the parser not to check they type  as required on compile time.
	native find(test => Boolean) T => Array.find(test,this.values)

	native static find(test=> Boolean,...values){
		values.each(v -> {
			test(v) => v
       	})
	}

	native find(infix test => Boolean){

	}

	native find(operator o = =, 1){

	}

	native push(){

	}


	native each(){

	}
}


class Token{

	infix is(...options) Boolean //throws "Miss Matched types"
	=> {
		// this means that find can take operator keyword test or regex
		isDefined(options.find => arg instanceOf this)
	}

	infix isLong(...options) => {
		Boolean bool = false
    	for($option in options){
    		bool = this instanceOf option => bool
		}

		bool
    }
}

class Parser{
	get nextToken{

	  	prevToken = cT;
		prevIndex = index;
		index += 1;
		$token = tokens[index];


		// this means
		// test end of file
		// if true do this and return last line
		!endOfFile => {

			token is NewLine -> {
				line += 1;
				col = 0;
			}

			isDefined(prevToken) -> col += prevToken.token.length

			 cT = considerSpaces ? token : (token.is(Space, Tab, NewLine) ? nextToken : token)
        }


	}
}