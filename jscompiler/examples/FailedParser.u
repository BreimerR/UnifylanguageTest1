

class Unify {
    constructor(tokens) {
        this.currentIndex = 0;
        this.tokens = tokens;
        this.tree = {
            function: {},
            classes: {},
            interfaces: {},
            traits: {},
            variables: {},
        };
    }


    static get parsers() {
        return [ClassParser, FunctionParser, StringParser, VariableParser]
    }


    init() {
        if (this.currentIndex < this.tokens.length) {
            let parser = new this.parser(null);
            this.currentIndex = parser.currentIndex;
        }
    }


    static getFunction() {
        return this.functions['name']
    }


    get parser() {
        for (let parser of Unify.parsers) {
            if (parser.shouldParse(this.tokens, this.currentIndex)) {
                return parser;
            }
        }


    }


}


class Parser {
    constructor(superBlock = null) {
        this.superBlock = superBlock;
    }

    static shouldParse(tokens = [], index = 0) {
        this.currentIndex = index;
        this.tokens = tokens;
    }


    get nextToken() {

    }


    /*Look into preventing redeclaration in this function*/
    static get nextToken() {
        let tokens = this.tokens, i = this.currentIndex++;
        if (i < tokens.length) {
            let token = tokens[i];

            if (this instanceof StringParser) {
                return token
            }

            return /[\s\t\n]/.test(token) ? this.nextToken : token;
        }

        return null;
    }

    static prevToken() {
        if (this.currentIndex < this.tokens.length) {

        } else {
            // no more tokens
            return null;
        }
    }
}


class ClassParser extends Parser {
    constructor() {
        super()
    }

    parse(instance) {

    }

    static get immediateToken() {
        return this.tokens[this.currentIndex++];
    }

    static get currentToken() {
        return this.tokens[this.currentIndex];
    }

    static shouldParse(tokens, startIndex = 0) {
        super.shouldParse(tokens, startIndex);
        let parseTree = {}, token;

        if ((token = this.nextToken) === "class") {
            if (/(_+)?[a-zA-Z][a-zA-Z_$]*/.test(token = this.nextToken)) {
                parseTree.IDENTIFIER = token;
                return true
            }
        }

        return false;
    }

    static shouldParseInheritance() {

    }

}


class FunctionParser extends Parser {

}

class StringParser extends Parser {

}

class VariableParser extends Parser {

a